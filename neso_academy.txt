################ INTRODUCTION TO DATA STRUCTURES

- DATA: COLLECTION OF CHAR, NUMBER OR SYMBOL
- INFORMATION: DATA THAT WE CAN EXTRACT SOME MEANING FROM IT

- IF DATA IS ARRANGED IN A SYSTEMATIC WAY THEN IT GETS A STRUCTURE AND BECOME MEANINGFUL
- TO PROVIDE AN APPROPRIATE WAY TO STRUCTURE THE DATA, WE NEED TO KNOW ABOUT DATA STRUCTURES

- WHAT IS DATA STRUCTURE?
- ORGANIZATION OF DATA IN SYSTEMATIC WAY SO THAT IT CAN BE USED EFFICIENTLY

- EXAMPLE:
- ARRAY
- INSTEAD OF CREATING MULTIPLE VARIABLE OF THE SAME TYPE (EX: MAKE 100 INTEGER VAR). WHY NOT CREATE AN ARRAY TO STORE ALL VALUES.
- STORING STRINGS IS EQUIVALENT TO STORING SEQUENCE OF CHARACTERS. TO WORK EFFICIENTLY WE CAN USE ARRAY OF CHAR 

- REAL APLICATION OF DATA STRUCTURE
- STACK DATA STRUCTURE IS USED IN IMPLEMENTING REDO AND UNDO FEATURE
- ARRAY DATA STRUCTURE IS USED TO STORE AN IMAGE AS A BITMAP
- GRAPH DATA STRUCTURE IS USED IN STORING THE FRIENDSHIP INFORMATION ON SOCIAL NETWORK SITE


############## DATA TYPES AND ABSTRACT DATA TYPES

- TWO IMPORTANT THINGS ABOUT DATA TYPES
- 1. DEFINES A CERTAIN DOMAIN OF VALUES (INT TYPE ONLY TAKE INTEGER VALUES)
- 2. DEFINES OPERATION ALLOWED ON THOSE VALUES (OPPERATION: ADDITION, SUBSTRACTION, MULTIPLICATION ETC)

- USER DEFINED DATA TYPES
- THE OPERATIONS AND VALUES OF USER DEFINED DATA TYPES ARE NOT SPECIFIED IN THE LANGUAGE ITSELF
- BUT IT SPECIFIED BY THE USER

- EXAMPLE:
- STRUCTURE
- UNION
- ENUMERATION

- ABSTRACT DATA TYPES (ADT)
- ADT'S ARE LIKE USER-DEFINED DATA TYPES WHICH DEFINES OPERATION ON VALUES USING FUNCTION 
- WITHOUT SPECIFYING WHAT IS INSIDE THE FUNCTION AND HOW THE OPERATIONS ARE PERFORMED.

- EXAMPLE:
- STACK ABSTRACT DATA TYPE

- OPERATIONS ON STACK
- initialize()
- push()
- pop()
- isEmpty()
- isFull()

- THINK OF ADT'S AS A BLACK BOX WHICH HIDES THE INNER STRUCTURE
- AND DESIGN OF THE DATA TYPE FROM THE USER

- THERE ARE MULTIPLE WAYS TO IMPLEMENT AN ADT
- 1. USING ARRAY OR LINKED LIST

- WHY WE USE ADT?
- THE PROGRAM THAT USED DATA STRUCTURE IS CALLED A CLIENT PROGRAM 
- CLIENT PROGRAM HAS ACCESS TO THE ADT LIKE INTERFACE
- THE PROGRAM WHICH IMPLEMENTS DATA STRUCTURE IN KNOWN AS THE IMPLEMENTATION
- IF SOMEONE WANTS TO USED THE STACK IN THE PROGRAM, THEN HE CAN SIMPLY USE PUSH AND POP OPERATIONS
- WITHOUT KNOWING ITS IMPLEMENTATION (HOW IT PERFORMED)
- IF IN THE FUTURE, THE IMPLEMENTATION OF STACK IS CHANGED FROM ARRAY TO LINKED LIST
- THE CLIENT PROGRAM WILL WORK IN THE SAME WAY WITHOUT BEING AFFECTED

- CONCLUSION:
- ABSTRACT DATA TYPES PROVIDES ABSTRACTION (HIDING DETAIL FROM THE USER)
 

################ DATA STRUCTURE

- DATA STRUCTURE IS USED TO IMPLEMENT ABSTRACT DATA STRUCTURE (ADT)
- ARRAY AND LINKED LIST ARE DATA STRUCTURE
- THEN WE CAN USE ARRAY AND LINKED LIST TO IMPLEMENT AN ADT

- ADT TELLS US WHAT IS TO BE DONE (BLUE PRINT)
- DATA STRUCTURE TELLS US HOW TO DO IT (IMPLEMENTATION)


- HOW TO KNOW WHICH DATA STRUCTURE TO USE FOR A PARTICULAR ADT?
- IN REALITY, DIFFERENT IMPLEMENTATIONS OF ADT ARE COMPARED FOR TIME AND EFFICIENCY
- THE ONE BEST SUITED ACCORDING TO THE CURRENT REQUIREMENT OF THE USER WILL BE SELECTED
- WHEN USER NEED TO SAVE SPACE, THEY WILL CHOOSE THE BEST DATA STRUCTURES TO ACCOMODATE THAT

- ADVANTAGES USING DATA STRUCTURES
- 1. EFFICIENCY: PROPER CHOICE OF DATA STRUCTURES MAKE PROGRAM EFFICIENT IN TERMS OF SPACE AND TIME
- 2. REUSABILITY: ONE IMPLEMENTATION CAN BE USED BY MULTIPLE CLIENT PROGRAMS
- 3. ABSTRACTION: DATA STRUCTURE IS SPECIFIED BY AN ADT WHICH PROVIDES A LEVEL OF ABSTRACTION.


############### TYPES OF DATA STRUCTURE

- # LINEAR DATA STRUCTURES
-   DATA STRUCTURE IS LINEAR WHEN ALL THE ELEMENTS ARE ARRANGED IN A LINEAR (SEQUENTIAL) ORDER,
-   HAVE ONLY ONE PREDECESSOR AND ONE SUCCESSOR
-   EXAMPLE: ARRAY, QUEU, LINKED LIST, STACK


- # NON-LINEAR DATA STRUCTURES
-   DATA STRUCTURE IS NON-LINEAR WHEN ALL THE ELEMENTS ARE NOT ARRANGED IN A LINEAR ORDER,
-   THERE IS NO LINEAR ARRANGEMENT OF THE ELEMENTS
-   EXAMPLE 1: TREE (BECAUSE ELEMENT IN TREE HAVE ONE PREDECESSOR BUT MORE THAN ONE SUCCESSOR)
-   EXAMPLE 2: GRAPH


- EVEN FURTHER DISTINCTION
- STATIC DATA STRUCTURES
- IN THESE TYPE OF DATA STRUCTURES, THE MEMORY IS ALLOCATED AT COMPILE TIME.
- THEREFORE, MAXIMUM SIZE IS FIXED
- ADVANTAGE OF STATIC DS: FAST ACCESS
- DISADVANTAGE OF STATIC DS: SLOWER INSERTION AND DELETION
- EXAMPLE OF STATIC DS: ARRAY

- DYNAMIC DATA STRUCTURES
- THE MEMORY IS ALLOCATED AT RUN TIME, THEREFORE MAXIMUM SIZE IS FLEXIBLE
- ADVANTAGE OF DYNAMIC DS: FAST INSERTION AND DELETION
- DISADVANTAGE OF DYNAMIC DS: SLOWER ACCESS
- EXAMPLE OF DYNAMIC DS: LINKED LIST


############### BASIC OF ASYMPTOTIC ANALYSIS PART 1

- IN ORDER TO USE DATA EFFICIENTLY, WE HAVE TO STORE IT EFFICIENTLY

- EFFICIENCY
- EFFICIENCY OF DATA STRUCTURES IS ALWAYS MEASURED IN TERMS OF TIME AND SPACE MEMORY
- THE IDEAL DS COULD BE THE ONE THAT TAKES THE LEAST POSSIBLE TIME FOR ALL ITS OPERATIONS
- AND CONSUMES THE LEAST MEMORY SPACE

- OUR FOCUS WILL BE ON FINDING THE TIME COMPLEXITY

- ON WHAT BASIS WE CAN COMPARE THE TIME COMPLEXITY OF THE DATA STRUCTURES?
- ANSWER: ON THE BASIS OF OPERATIONS PERFORMED ON THEM

- EXAMPLE 1:
- WE HAVE AN ARRAY OF INT WITH 8 ELEMENT
- WE NEED TO ADD NEW DATA AT THE BEGINNING OF ARRAY
- THE PROCESS, WE SHIFT THE CURRENT DATA TO THE RIGHT AND ADD NEW DATA TO THE BEGINING OF THE ARRAY
- THIS PROCESS IS RELATIVELY DIFFICULT

- EXAMPLE 2:
- WE HAVE DS OF TYPE LINKED LIST
- LINKED LIST IS NOTHING BUT SEQUENCE OF NODE THAT CONNECT TO EACH OTHER
- WE NEED TO ADD NEW DATA AT THE BEGINING OF THE LINKED LIST
- THE PROCESS, WE ADD NEW DATA AND ASSIGN THE ADDRESS OF HEAD NOED TO THE POINTER PART OF NEW DATA
- THIS PROCESS IS RELATIVELY EASY

- CONCLUSION:
- FROM EXAMPLE 1 AND 2 WE CAN CONCLUDE THAT
- IF WE WANT TO ADD NEW DATA AT THE BEGINING THE BEST CHOICE IS USE LINKED LIST OVER ARRAY
- THIS IS WHAT IT MEAN BY TIME COMPLEXITY
- WE CHOOSE DS THAT CAN SATISFY WHAT WE NEED IN THE LESS TIME


############### BASIC OF ASYMPTOTIC ANALYSIS PART 2

- BUT HOW TO FIND THE TIME COMPLEXITY
- OR RUNNING TIME OF AN OPERATION PERFORMED ON DATA STRUCTURES?

- METHOD 1: EXAMINE THE EXACT RUNNING TIME
  PICK UP SOME MACHINE AND TURN THE TIMER ON
  RUN THE OPERATION FOR DIFFERENT INPUTS ON THE DS YOU WANT TO COMPARE ONE BY ONE
  SEE THE DIFFERENCE BETWEEN THOSE
  THE ONE WHO TAKE LESS TIME IS THE BEST PERFORMER
  BUT THIS METHOD IS NOT PRACTICAL AT ALL


############## BASIC OF ASYMPTOTIC ANALYSIS PART 3

- EXAMINING THE EXACT RUNNING TIME IS NOT THE BEST SOLUTION TO CALCULATE THE TIME COMPLEXITY
- POINTS TO BE NOTED
- 1. MEASURING THE ACTUAL RUNNING TIME IS NOT PRACTICAL AT ALL
- 2. THE RUNNING TIME GENERALLY DEPENDS ON THE SIZE OF THE INPUT

- LET'S TALK ABOUT THE SIZE OF THE INPUT
- WHEN WE HAVE ARRAY OF 3 ELEMENT AND NEED TO ADD NEW DATA TO THE BEGINING
- THAT'S MEAN WE NEED TO SHIFT 3 DATA. EACH SHIFT SPEND 1 UNITS OF TIME, SO SHIFT 3 DATA SPEND 3 UNITS OF TIME
- WHAT IF THE ARRAY CONSIST OF 1.000 ELEMENT AND WE NEED TO ADD NEW DATA AT THE BEGINNING?
- IT WILL SPEND 1000 UNIT OF TIME (TO LONG)
- THE TIME SPEND DEPENDS ON THE SIZE OF INPUT

- THEREFORE, IF THE SIZE OF THE INPUT IS n, THEN f(n) IS A FUNCTION OF n DENOTES THE TIME COMPLEXITY
- IN OTHER WORDS, f(n) REPRESENTS THE NUMBER OF INSTRUCTIONS EXECUTED FOR THE INPUT VALUE n
- EXAMPLE:
  for(1=0; i < n; i++){

   printf("Hello World");
  }
  MEANS: printf INSTRUCTION IS EXECUTED n NUMBER OF TIMES.
  THEREFORE: f(n) = n

- BUT, HOW TO FIND f(n)?
- WE CAN COMPARE TWO Ds FOR A PARTICULAR OPERATION BY COMPARING THEIR f(n) VALUES
- WE ARE INTERESTED IN THE GROWTH RATE OF f(n) WITH RESPECT TO n
- BECAUSE IT MIGHT BE POSSIBLE FOR SMALLER INPUT SIZE GIVE A BETTER PERFORMANCE FOR A DS
- BUT IT GIVE POOR PERFORMANCE WHEN DS GET BIGGER INPUT.

- THIS CONCEPT IS APPLICABLE IN COMPARING THE TWO ALGORITHMS AS WELL 

- EXAMPLE:
- f(n) = 5n^2 + 6n + 12

- for n = 1
- % of running time due to 5n^2 = (5 / 5 + 6 + 12) * 100 = 21.74% 

- % of running time due to 6n = (6 / 5 + 6 + 12) * 100 = 26.09% 

- % of running time due to 12 = (12 / 5 + 6 + 12) * 100 = 52.17% 

- FROM CALCULATION ABOVE, IT IT LIKE THE MOST TIME CONSUME BY 12
- BUT WE HAVE TO SEE THE GROWTH RATE BY ASSIGN A BIGGER VALUE TO n

- n = 10; 5n^2 = 87.41%; 6n = 10.49%; 12 = 2,09%;
- n = 100; 5n^2 = 98.79%; 6n = 1.19%; 12 = 0.02%;
- n = 1000; 5n^2 = 99.88%; 6n = 0.12%; 12 = 0.0002%;

- FROM EXTENTION CALCULATION, AS THE INPUT GET LARGER IT IS LIKE THE MOST TIME CONSUME BY 5n^2
- SO THERE IS NO HARM IF WE ELIMINATE THE REST OF TERM (6n + 12) AS THEY ARE NOT CONTRIBUTING THAT MUCH
- THUS, f(n) = 5n^2

- NOW WE ARE GETTING THE APPROXIMATE TIME COMPLEXITY AND WE ARE SATISFIED WITH THIS RESULT
- BECAUSE THIS APPROXIMATE RESULT IS VERY NEAR TO THE ACTUAL RESULT

- THIS CONCEPT OF CALCULATING THE APPROXIMATE MEASURE OF TIME COMPLEXITY IS CALLED
- ASYMPTOTIC COMPLEXITY


############### BASIC OF ASYMPTOTIC ANALYSIS PART 4

- BIG O NOTATION IS USED TO MEASURE THE PERFORMANCE OF ANY ALGORITHM 
- BY PROVIDING THE ORDER OF GROWTH OF THE FUNCTION
- IT GIVES THE UPPER BOUND ON A FUNCTION BY WHICH WE CAN MAKE SURE THAT 
- THE FUNCTION WILL NEVER GROW FASTER THAN THIS UPPER BOUND

- WHAT WE WANT? WE WANT THE APPROXIMATE RUNTIME OF THE OPERATIONS PERFORMED ON DS
- BIG O NOTATION WILL HELP US TO ACHIEVE THE SAME

- IF f(n) AND g(n) ARE TWO FUNCTIONS, THEN 
- f(n) == O(g(n))

- IF THERE EXIST CONSTANTS c AND n0 SUCH THAT
- f(n) <= c.g(n), FOR ALL n >= n0

- THIS MEANS, f(n) GROWTH IS LINEAR OR DOES NOT GROW FASTER THAN g(n)

- EXAMPLE 1:
- f(n) = n;   g(n) = 2n;
- IS f(n) = O(g(n))?

- ANSWER
- f(n) <= C.(g(n))
- n <= C.2n;    FOR c = 1;  n0 = 1;
- 1 <= 2; //IT IS TRUE

- THIS MEANS f(n) WILL GROM LINEARLY

- EXAMPLE 2: 
- f(n) = 4n + 3;   g(n) = n;
- IS f(n) = O(g(n))?

- ANSWER
- f(n) <= c.(g(n))
- 4n + 3 <= c.n;    FINC VALUE OF c SO THE FUNCTION WILL TRUE
- TAKE c = 5
- 4n + 3 <= 5n
- 3 <= 5n - 4n
- 3 <= n

- THEREFORE:
- f(n) <= O(g(n)); FOR ALL n >= 3; WHERE c = 5; n0 = 3
- f(n) = O(n)
- MEANING THE GROWTH RATE OF THIS FUNCTION IS LINEAR

- THIS MEANS f(n) WILL GROM LINEARLY

- EXAMPLE 2:


############### BASIC OF ASYMPTOTIC ANALYSIS PART 5

- WE ARE ALWAYS INTERESTED IN FINDING THE GROWTH RATE OF THE FUNCTION
- WE TAKE ONE FUNCTION UNDER CONSIDERATION
- WE USED TO COMPARE IT WITH THE SIZE OF THE INPUT
- WE NEED TO KNOW HOW OUR FUNCTION GROWS AS SIZE OF THE INPUT GROWS

- FOR THIS PURPOSE, WE PLUG IN DIFFERENT VALUES OF N INTO THE FUNCTION
- AND PLOT A GRAPH TO SEE HOW IT GROWS

- BUT WHY WE NEED TO DO THIS?

- LET SAY WE ARE COMPARING TWO DATA STRUCTURES FOR A PARTICULAR OPERATION
- IT MIGHT BE POSSIBLE THAT FOR SOME SET OF INPUTS, FIRST DS MAY GIVE THE BEST RESULTS
- WHILE FOR SOME OTHER SET OF INPUTS, SECOND DS MAY GIVE THE BEST RESULTS

- WE CAN'T SIMPLY PREDICT THAT AFTER WHICH VALUE OF n,
- WE CAN BE SURE THAT THE ONE DS WILL PERFORM BETTER THAN OTHER DS 

- LINEAR GRAPHIC OF f(n) AND g(n) WHICH g(n) PERFORM BETTER THAN f(n) WHEN n < 3
- BUT f(n) PERFORM BETTER THAN g(n) WHEN n > 3

- THIS IS THE REASON WHY WE PLUGGIN IN DIFFERENT VALUE OF n 
- AND ARE INTERESTED IN THE GROWTH RATE OF THE FUNCTIONS REPRESENTING THE TIME 
- TAKEN BY THE OPERATIONS PERFORMED ON DS

- BUT ISN'T IT A TEDIOUS WORK TO PLUG IN DIFFERENT VALUE OF n
- AND FIND THE GROWTH RATE OF THE FUNCTIONS FOR COMPARISON PURPOSE?

- THIS IS WHERE THE BIG O NOTATION COME THE RESCUE

- BIG O NOTATION HELPS US FINDING THE GROWTH RATE OF THE FUNCTION 
- WITHOUT PLUGGING IN DIFFERENT VALUES OF n
- THE BEST PART IS, IT GIVES THE LEAST UPPER BOUND ON THE FUNCTION
- WHICH GIVES THE SURETY THAT THE FUNCTION UNDER CONSIDERATION
- WILL NEVER GROW FASTER THAN THIS UPPER BOUND

- THAT LEAST UPPER BOUND TELLS HOW WORST AN ALGORITHM CAN PERFORM

- EXAMPLE:
f(n) = 5n^2 + 4;  g(n) = n^2

IS f(n) <= O(g(n)) ?

f(n) <= c.g(n)

5n^2 + 4 <= c.n^2; Let's take c = 6
5n^2 + 4 <= 6n^2
4 <= n^2
2 <= n
n >= 2

THIS MEANS
f(n) <= c.g(n)
when n >= 2 and c = 6; n0 = 2

f(n) = O(n^2)

O(n^2) IS THE WORST CASE OF f(n)
THIS MEANS
f(n) will never grow quadratic

- BIG O NOTATION IS SIMPLYFYING THE TASK.
- IT ELIMINATES ALL THE UNNECESSARY TERMS FROM THE FUNCTION
- WHICH ARE NOT CONTRIBUTING MUCH IN THE OVERALL RUNNING TIME

- GROWTH RATE OF STANDARD FUNCTIONS
- log2n -> least upper bound
- n
- nlog2n
- n^2
- n^3
- 2^n

- PROGRAM TO CALCULATE SUM OF FIRST N NATURAL NUMBERS

int main(){

 int i, sum = 0, n;  ->execute 1 time
 scanf("%d",&n);		   ->execute 1 time

 for(i=1;i<n;i++){
 
  sum = sum + i      ->execute n times
 }

 printf("%d",sum);   ->execute 1 time
 return 0;           ->execute 1 time
}

n=3 sum=3
n=4 sum=6
n=5 sum=10


- THE FUNCTION IS f(n) = n + 4

f(n) = n + 4;   LET g(n) = n;

IS f(n) = O(g(n)) ?

f(n) <= c.g(n)

n + 4 <= c.n; Let's take c = 2
n + 4 <= 2n
4 <= n
n >= 4


THIS MEANS
f(n) <= c.g(n)
when n >= 4 and c = 2; n0 = 4

f(n) = O(n)

O(n) IS THE WORST CASE OF f(n)
THIS MEANS
f(n) growth can only be linear

- BIG O NOTATION IS SIMPLYFYING THE TASK.
- IT ELIMINATES ALL THE UNNECESSARY TERMS FROM THE FUNCTION
- WHICH ARE NOT CONTRIBUTING MUCH IN THE OVERALL RUNNING TIME


- PROGRAM TO CALCULATE SUM OF FIRST N NATURAL NUMBERS version 2

int main(){

 int i,sum=0,n;            ->execute 1 time
 scanf("%d",&n);											->execute 1 time
 printf("%d",n*(n-1)/2);   ->execute 1 time
 return 0;                 ->execute 1 time
}

f(n) = 4;   LET g(n) = 1;

IS f(n) = O(g(n)) ?

f(n) <= c.g(n)

4 <= c.1; Let's take c = 5
4 <= 5

THIS MEANS
f(n) <= c.g(n)
when c = 2; n0 = 1

f(n) = O(1)  -> meaning constant growth

- FROM THIS TWO PROGRAM WE CAN CONCLUDE THAT
- VERSION 2 IS BETTER THAN VERSION 1
- BECAUSE THE GROWTH RATE OF FUNCTION IN VERSION 2 IS CONSTANT

